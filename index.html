<style>
	body {
		margin: 0;
	}

	td {
		background: black;
		border: 1px solid white;
		padding: 40px;
	}

	td.firing {
		background: white;
		border: 1px solid black;
	}

	table {
		border-collapse: collapse;
		margin: 10vh auto;
	}

	div {
		display: flex;
		justify-content: center;
	}

	.salmon {
		border-color: salmon;
	}

	.chartreuse {
		border-color: chartreuse;
	}

	.burlywood {
		border-color: burlywood;
	}

	.cornflowerblue {
		border-color: cornflowerblue;
	}

	.darkmagenta {
		border-color: darkmagenta;
	}

	.salmon.firing {
		background: salmon;
		color: white;
	}

	.chartreuse.firing {
		background: chartreuse;
		color: white;
	}

	.burlywood.firing {
		background: burlywood;
		color: white;
	}

	.cornflowerblue.firing {
		background: cornflowerblue;
		color: white;
	}

	.darkmagenta.firing {
		background: darkmagenta;
		color: white;
	}

	.neuron {
		background: white;
		color: black;
		border-radius: 50%;
		border-style: solid;
		margin: 1em;
	}

	.dendrite {
		height: 50px;
		width: 50px;
		border-color: #00000000;
		border-style: solid;
	}
</style>
<body>
	<table>
	</table>
	<div>
		<svg id="nextLevelButton" onclick="nextlevel()" viewBox="0 0 459 459" height="2em">
			<path d="M229.5,0C102.751,0,0,102.751,0,229.5S102.751,459,229.5,459S459,356.249,459,229.5S356.249,0,229.5,0z M310.292,239.651 l-111.764,76.084c-3.761,2.56-8.63,2.831-12.652,0.704c-4.022-2.128-6.538-6.305-6.538-10.855V153.416 c0-4.55,2.516-8.727,6.538-10.855c4.022-2.127,8.891-1.857,12.652,0.704l111.764,76.084c3.359,2.287,5.37,6.087,5.37,10.151 C315.662,233.564,313.652,237.364,310.292,239.651z"></path>
		</svg>
	</div>
</body>
<script>
	const prelevel1 = {name:"prelevel1", visualfield:[[]], layers:["retina"], neurons:[[1]], nextLevel:"prelevel2"}
	const prelevel2 = {name:"prelevel2", visualfield:[[]], layers:["retina","middle"], neurons:[[1],[2]], nextLevel:"prelevel3"}
	const prelevel3 = {name:"prelevel3", visualfield:[[]], layers:["retina","middle"], neurons:[[1,2],[3]], nextLevel:"level1"}
	const level1 = {name:"level1", visualfield:[[1,2,3,4,5]], layers:["retina","middle"], neurons:[[1,2,3,4,5],[6,7,8]], nextLevel:""}

	var currentLevel = "" //variable to keep track of current level, used for remembering built synapses

	function populate(layerId, layer) {
		let color = ["salmon", "chartreuse", "burlywood", "cornflowerblue", "darkmagenta"][Math.floor(Math.random() * 5)]
		let layerElement = document.createElement("div")
		layerElement.id = layerId
		layerElement.classList.add("layer")
		document.body.appendChild(layerElement)
		for (const neuron of layer) {
			let neuronElement = document.createElement("div")
			neuronElement.id = neuron.toString() + "+"
			neuronElement.classList.add("neuron")
			neuronElement.classList.add(layerId)
			neuronElement.classList.add(color)
			neuronElement.setAttribute("ondragover", "event.preventDefault()")
			neuronElement.setAttribute("ondrop", "formSynapse(event)")
			let dendrite = document.createElement("div")
			dendrite.id = neuron.toString()
			dendrite.draggable = true
			dendrite.classList.add("dendrite")
			dendrite.setAttribute("ondragstart", "event.dataTransfer.setData('presynapticID', event.target.id)")
			neuronElement.appendChild(dendrite)
			document.getElementById(layerId).appendChild(neuronElement)
		}
	} //creates HTML elements representing neurons, used by the generate function

	function generate(level) {
		currentLevel = level.name
		let elementsFromPreviousLevel = document.getElementsByClassName("layer")
		while (elementsFromPreviousLevel.length > 0) elementsFromPreviousLevel[0].remove()
		for (i = 0; i < level.layers.length; i++) {
			populate(level.layers[i],level.neurons[i])
		}
		document.getElementById("nextLevelButton").setAttribute("onclick", "generate(" + level.nextLevel + ")")
	} //parses level data

	function formSynapse(event) {
		let presynapticID = event.dataTransfer.getData("presynapticID")
		let postsynapticID = event.target.id
		if (localStorage.getItem(postsynapticID) != null) {
			let inputs = JSON.parse(localStorage.getItem(postsynapticID))
			if (inputs.indexOf(presynapticID)==-1) inputs.push(presynapticID)
			localStorage.setItem(postsynapticID, JSON.stringify(inputs))
		}
		else {
			localStorage.setItem(postsynapticID, JSON.stringify([presynapticID]))
		}
	}

	function fire(neuron) {
		var y = 0;
		if (neuron == 0) {} else {
			for (const input of neuron) {
				if (document.getElementById(input.toString()).classList.contains("firing")) {
					y++
				}
			}
			if (y == neuron.length) {
				document.getElementById(neuron.id).classList.add("firing")
			} else {
				document.getElementById(neuron.id).classList.remove("firing")
			}
		}
	} //legacy code from eliasmith's network

	function propagate(neuron) {
		neuronsToToggle = []
		for (const retinalNeuron of neuronsToToggle.unique()) {
			console.log("trying to change neuron" + retinalNeuron.toString())
			changeState(retinalNeuron)
		}
		for (const neuron of cortex.n) {
			fire(neuron)
		}
		for (const neuron of complex.n) {
			recognise(neuron)
		}
		for (const neuron of it.n) {
			recognise(neuron)
		}
	} //legacy code from eliasmith's network

	function recognise(neuron) {
		var y = 0;
		for (const input of neuron) {
			if (document.getElementById(input.toString()).classList.contains("firing")) {
				y++
			}
		}
		if (y >= 1) {
			document.getElementById(neuron.id.toString()).classList.add("firing")
		} else {
			document.getElementById(neuron.id.toString()).classList.remove("firing")
		}
	} //legacy code from eliasmith's network

	var oscillator = 0 //maintains periodic spike

	function spike() {
		oscillator += 1
		for (const x of Array.from(document.getElementsByClassName('retina'))) {
			x.classList.add('firing')
		}
		if (oscillator === 5) {
			clearInterval(spikeInterval)
			restInterval = setInterval(rest, 100)
		}
	} //maintains periodic spike

	function rest() {
		oscillator -= 0.25
		for (const x of Array.from(document.getElementsByClassName('retina'))) {
			x.classList.remove('firing')
		}
		if (oscillator === 0) {
			clearInterval(restInterval)
			pulse()
		}
	} //maintains periodic spike

	function pulse() {
		spikeInterval = setInterval(spike, 100)
	} //maintains periodic spike

	generate(prelevel1) //starts from level 0

	pulse() //starts periodic spike
</script>
